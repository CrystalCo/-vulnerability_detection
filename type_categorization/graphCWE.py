import requests
import pandas as pd
from queue import Queue
from Node import Node

"""
    Methods used in 2_Clustering_By_Abstraction.ipynb to create a hierarchical tree of CWE relationships.
"""

def create_cwe_node(cwe_id, df):
    df_copy = df.set_index(['CWE_ID'])
    node = Node(cwe_id)
    node.name = df_copy.loc[cwe_id]['Name']
    node.abstraction = df_copy.loc[cwe_id]['Abstraction']
    return node

def create_category_nodes(categories, df, nodes):
    # Creates new nodes for high level groups not found in Research Concepts
    df_copy = df.set_index(['CWE_ID'])
    for cwe in categories:
        node = Node(cwe)
        node.abstraction = 'Category'
        node.active = True
        node.name = df_copy.loc[cwe]['Name']
        node.count = df_copy.loc[cwe]['cwe_count']
        # No need to get parents or children since this group has neither, hence no need to call flag_active() since no branches exist.
        nodes[cwe] = node

def parse_parents(related):
    """
        INPUT:
            related := String. Contains the relationships of a CWE. 
                        Example, "::NATURE:ChildOf:CWE ID:828:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:663:VIEW ID:1000::NATURE:CanPrecede:CWE ID:123:VIEW ID:1000::"

        OUTPUT:
            an array of 0 or 1 integers.  Integers represent the parent ID. If none, means no parent (aka must be a top-level group)
    """
    split_related = related.split('::')[1:-1] # Remove whitespaces at beginning and end
    childOf = [x for x in split_related if ('ChildOf' in x) and ('VIEW ID:1000' in x) and ('ORDINAL:Primary' in x)]
    parent = []
    if len(childOf) == 1:
        cwe_id = int(childOf[0].split(':')[3])
        parent.append(cwe_id)
    elif len(childOf) > 1:
        print(f'WARNING: More than one parent found for CWE-{cwe_id}!!')
    return parent
    
def assign_relationships(nodes):
    for nid in nodes:
        node = nodes[nid]
        # assign parents to node
        if len(node.parents) > 2:
            print(f'WARNING!  More than 1 parent node found in CWE-{node.id}')
        elif len(node.parents) == 1:
            pid = node.parents.pop()
            node.parents = []
            node.parents.append(nodes[pid])
            # assign children
            if node in nodes[pid].children:
                print(f'WARNING: potential duplicate CWE-{node.id} b/c node was already in parents children array. Parent ID-{pid}')
            else:
                nodes[pid].children.append(node)

def create_nodes_dict(df):
    # Create dictionary holding all vertices (aka nodes)
    nodes = dict()

    for i, row in df.iterrows():
        cwe_id = row['CWE_ID']
        if cwe_id not in nodes:
            # create new node to add to dictionary
            node = create_cwe_node(cwe_id, df)
            related = row['Relationships']
            # get parents if applicable. rows with strings contain relationships.  rows w/NaN or empty are most likely top-level group (e.g. Pillars)
            if type(related) == str:
                parents = parse_parents(related)  # returns an array with either 1 or 0 integers.  Later will update with actual reference to parent node in assign_relationships().
                node.parents = parents          # technically not overwriting since this will be the first pass                
            nodes[cwe_id] = node
        else:
            print(f'Duplicate node detected in data! CWE-{cwe_id}')
                                    
    return nodes


def flag_active(node, nodes):
    if node.parents == []:
        return
    for parent in node.parents:
        cwe_id = parent.id
        nodes[cwe_id].active = True
        flag_active(nodes[cwe_id], nodes)

def add_counts(df, nodes):
    """
        Takes the counts from our cwe_df table, insert them into our nodes dictionary, & 'activates' the node (for printing purposes).
        Returns:
            - nodes dict with updated count & active flag, 
            - a list of missing cwes that were not in the nodes dictionary.
    """
    cwes_missing = []

    for i, row in df.iterrows():
        cwe_id = row['CWE_ID']

        if cwe_id in nodes:
            nodes[cwe_id].count = row['cwe_count']
            nodes[cwe_id].active = True
            flag_active(nodes[cwe_id], nodes)
        else:
            cwes_missing.append(cwe_id)
    return nodes, cwes_missing

def get_top_level(nodes):
    """
        Returns an array of Pillar & Category nodes.
        Has its own function because Pillars & Categories are not an abstraction, 
        and therefore do not contain the root in their relationship column.
    """
    groups = []
    for n_id in nodes:
        node = nodes[n_id]
        if (node.abstraction == 'Pillar') or (node.abstraction == 'Category'):
            groups.append(node)
    return groups

def get_group_sum(groups_array):
    """
        Gets the sum of all the examples per group.
        Returns an array of tuples in the form (group ID + group name, sum), 
        and an array of tuples that contain duplicate nodes (i.e. nodes found in multiple groups)
    """
    group_sum = [] # array of tuples 
    # Find which nodes are in other groups 
    global_explored = set() # Avoids risk of duplicate counts for CWEs contained in other groups
    global_explored_arr = []
    
    for group in groups_array:
        count = 0
        name = 'CWE-%d: %s' % (group.id, group.name)

        q = Queue()
        q.put(group)
        explored = set()
        
        while not q.empty():
            node = q.get()
            explored.add(node) # Avoids risk of duplicate counts (e.g. CWE-122 is a child of both CWE-787 & CWE-788)
            if node in global_explored and node.count > 0:
                global_explored_arr.append((name, node.id, node.name, node.count))
            else:
                global_explored.add(node)
                count += node.count
            
            for child in node.children:
                if child not in explored:
                    q.put(child)
        
        group_sum.append((name, count))
        
    return group_sum, global_explored_arr
