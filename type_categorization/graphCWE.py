import requests
import numpy as np
import pandas as pd
from queue import Queue
from Node import Node

"""
    Methods used in 2_Clustering_By_Abstraction.ipynb to create a hierarchical tree of CWE relationships.
"""

def create_cwe_node(cwe_id, df):
    df_copy = df.set_index(['CWE_ID'])
    node = Node(cwe_id)
    node.name = df_copy.loc[cwe_id]['Name']
    node.abstraction = df_copy.loc[cwe_id]['Abstraction']
    return node

def parse_parents(related):
    split_related = related.split('::')[1:-1] # Remove whitespaces at beginning and end
    childOf = [x for x in split_related if ('ChildOf' in x) and ('VIEW ID:1000' in x)]
    parents = []
    for parent in childOf:
        cwe_id = parent.split(':')[3]
        cwe_id = int(cwe_id)
        parents.append(cwe_id)
    return parents
    
def assign_relationships(parent, df, node, nodes):
    # create new node for parent
    pnode = create_cwe_node(parent, df)
    # assign children to parent
    pnode.children.append(node)
    # assign parents to node
    node.parents.append(pnode)
    # assign parent a place in the nodes dict
    nodes[parent] = pnode

def create_nodes_dict(df):
    # Create dictionary holding all vertices (aka nodes)
    nodes = dict()

    for i, row in df.iterrows():
        cwe_id = row['CWE_ID']
        if cwe_id not in nodes:
            # create new node to add to dictionary
            node = create_cwe_node(cwe_id, df)
            related = row['Relationships']
            # get parents if applicable. rows with strings contain relationships.  rows w/NaN or empty are most likely top-level group (e.g. Pillars)
            if type(related) == str:
                parents = parse_parents(related)
                for parent in parents:
                    if parent not in nodes:
                        assign_relationships(parent, df, node, nodes)
                    else:
                        node.parents.append(nodes[parent])
                        if node not in nodes[parent].children:
                            nodes[parent].children.append(node)
            nodes[cwe_id] = node
        else:
            # check if existing node has any missing information (e.g. parents, children)
            node = nodes[cwe_id]
            related = row['Relationships']
            if (type(related) == str):
                parents = parse_parents(related)
                for parent in parents:
                    if parent not in nodes:
                        assign_relationships(parent, df, node, nodes)
                    else:
                        if nodes[parent] not in node.parents:
                            node.parents.append(nodes[parent])
                        if node not in nodes[parent].children:
                            nodes[parent].children.append(node)
                                    
    return nodes

def flag_active(node, nodes):
    if node.parents == []:
        return
    for parent in node.parents:
        cwe_id = parent.id
        # Our global nodes dict
        nodes[cwe_id].active = True
        flag_active(nodes[cwe_id], nodes)

def add_counts(df, nodes):
    """
        Takes the counts from our cwe_df table, insert them into our nodes dictionary, & 'activates' the node (for printing purposes).
        Returns:
            - nodes dict with updated count & active flag, 
            - a list of missing cwes that were not in the nodes dictionary.
    """
    cwes_missing = []

    for i, row in df.iterrows():
        cwe_id = row['CWE_ID']

        if cwe_id in nodes:
            nodes[cwe_id].count = row['cwe_count']
            nodes[cwe_id].active = True
            flag_active(nodes[cwe_id], nodes)
        else:
            cwes_missing.append(cwe_id)
    return nodes, cwes_missing

def get_top_level(nodes):
    """
        Returns an array of Pillar & Category nodes.
        Has its own function because Pillars & Categories are not an abstraction, 
        and therefore do not contain the root in their relationship column.
    """
    groups = []
    for n_id in nodes:
        node = nodes[n_id]
        if (node.abstraction == 'Pillar') or (node.abstraction == 'Category'):
            groups.append(node)
    return groups

def get_group_sum(groups_array):
    """
        Gets the sum of all the examples per group.
        Returns an array of tuples in the form (group name, sum), 
        and an array of tuples that contain duplicate nodes (i.e. nodes found in multiple groups)
    """
    group_sum = [] # array of tuples 
    # Find which nodes are in other groups 
    global_explored = set() # Avoids risk of duplicate counts for CWEs contained in other groups
    global_explored_arr = []
    
    for group in groups_array:
        count = group.count
        name = group.name
        
        q = Queue()
        q.put(group)
        explored = set()
        
        while not q.empty():
            node = q.get()
            explored.add(node) # Avoids risk of duplicate counts (e.g. CWE-122 is a child of both CWE-787 & CWE-788)
            if node in global_explored and node.count > 0:
                global_explored_arr.append((group.id, name, node.id, node.name, node.count))
            else:
                global_explored.add(node)
            count += node.count
            
            for child in node.children:
                if child not in explored: # TODO: Should I also do `not in global_explored` for counts to be closer to slice samples?  Might be ok to have duplicates so we can have more examples, but that also might cause confusion in classification.  Perhaps better to assign these to the group with less samples.
                    q.put(child)
        
        group_sum.append((name, count))
        
    return group_sum, global_explored_arr
