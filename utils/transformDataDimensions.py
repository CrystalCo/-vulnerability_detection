import os, pickle 

import numpy as np

def getAvgLength(arr):
    """
        Return avg length of the inner arrays within an array,
        and the list of all the lengths in case you want to pick a value other than the avg.
    """
    totalSamples = len(arr)
    totalVectorLen = 0
    vectorLengths = []

    for a in arr:
        v_length = len(a) 
        totalVectorLen += v_length
        vectorLengths.append(v_length)

    vectorLengths.sort()

    meanLen = int(totalVectorLen/totalSamples)
    return meanLen, vectorLengths


def truncateRows(X, maxlen):
    """
        Transforms the length of inner arrays within an array 
        to `maxlen` size. If shape of data is less than maxlen,
        pads remainder with zeros.  Else, truncates the remaining data.

        INPUTS:
            X := nested array of data
            maxlen := int; number of rows to keep
        OUTPUT:
            Reshaped data
    """
    vector_dim = len(X[0][0])
    fill_0 = [0] * vector_dim
    if (maxlen != 0):
        new_X = []
        for x in X:  
            # len(x) is how many symbols in 1 program.
            if len(x) <  maxlen:
                x = x + [fill_0] * (maxlen - len(x))
                new_X.append(x)
            else:
                # length of vector is > maxlen
                new_X.append(x[:maxlen])
    print ("New Vector Length: ", len(new_X[0]))
    return new_X

def tranformDimsByFocus(fromTrainDataPath, fromTestDataPath, toTrainDataPath, toTestDataPath, maxLen, vector_dim, vType='balanced'):
    """
        Transforms the length of inner arrays within an array to `maxlen` size. 
        If shape of data is < maxlen, pads remainder with zeros.  If shape
        is > maxlen, truncates (maxlen/2) to the left and right of focus pointer.

        INPUTS:
            string paths that point to 
        OUTPUT:
            Reshaped data
    """
    print("Loading data...")
    print("Train set")
    for filename in os.listdir(fromTrainDataPath):
        if not filename.endswith(".pkl"):
            continue
        if vType not in filename:
            continue
        # Transform Data
        dataPath = os.path.join(fromTrainDataPath, filename)
        data = reshapeData(dataPath, maxLen, vector_dim)
        dataPath = os.path.join(toTrainDataPath, "DL_Final_" + filename)
        f_train = open(dataPath, 'wb')
        pickle.dump(data, f_train)
        f_train.close()
    
    print("\nTest set")
    for filename in os.listdir(fromTestDataPath):
        if not (vType in filename):
            continue
        if not (filename.endswith(".pkl")):
            continue
        dataPath = os.path.join(fromTestDataPath, filename)
        data = reshapeData(dataPath, maxLen, vector_dim)
        dataPath = os.path.join(toTestDataPath, "DL_Final_" + filename)
        f_test = open(dataPath, 'wb')
        pickle.dump(data, f_test)
        f_test.close()


def reshapeData(dataSetpath, maxlen, vector_dim):
    """
        Truncates row length of data to match maxlen size, centering around 
        the focuspointer to ensure the data returned still contains the part where the vulnerability lies in order to produce suitable data.
    """
    f1 = open(dataSetpath, 'rb')
    X, _, focuspointers = pickle.load(f1)
    f1.close()

    fill_0 = [0]*vector_dim
    new_X = []
    
    for x, focus in zip(X, focuspointers):
        if len(x) <  maxlen:
            x = x + [fill_0] * (maxlen - len(x))
            new_X.append(x)
        elif len(x) == maxlen:
            new_X.append(x)
        else:
            startpoint = int(focus - round(maxlen / 2.0))
            endpoint =  int(startpoint + maxlen)
            if startpoint < 0:
                startpoint = 0
                endpoint = maxlen
            if endpoint >= len(x):
                startpoint = -maxlen
                endpoint = None
            new_X.append(x[startpoint:endpoint])

    X = new_X

    return X

