import pickle
import random
import time
import math
import os

import numpy as np
from sklearn.base import BaseEstimator
# from tensorflow.keras.metrics import TruePositives, TrueNegatives,FalsePositives, FalseNegatives
from keras.preprocessing import sequence
from keras import optimizers 
from keras.optimizers import SGD
from keras.models import Sequential
from keras.layers.core import Masking, Dense, Dropout, Activation
from keras.layers.recurrent import LSTM,GRU
from keras.layers.wrappers import Bidirectional

from SYSE_1_isVulnerable.preprocess_dl_Input_version5 import *
from SYSE_1_isVulnerable.DLPrediction import tranfromInput
from utils.utils import get_category

def create_bgru_model(maxlen, vector_dim=30, layers=2, dropout=0.1, optimizer='adam'):
    print('\nBuild BGRU Model')
    model = Sequential()
    model.add(Masking(mask_value=0.0, input_shape=(maxlen, vector_dim)))
    for i in range(1, layers):
        model.add(Bidirectional(GRU(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid', return_sequences=True)))
        model.add(Dropout(dropout))
    model.add(Bidirectional(GRU(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid')))
    model.add(Dropout(dropout))
    model.add(Dense(9, activation='sigmoid')) # Dense() outputs a function which takes a tensor as input and outputs a tensor. Might be our 'last' layer...
    model.compile(loss='categorical_crossentropy', optimizer=optimizer, metrics=['accuracy'])
    model.summary() # WORKS! Up to here

    return model
"""
    Returns error:

    /Users/crystalcontreras/Desktop/DePaul/VulnerabilitiesResearch/vulnerability_detection/env38/lib/python3.8/site-packages/sklearn/model_selection/_validation.py:615: FitFailedWarning: Estimator fit failed. The score on this train-test partition for these parameters will be set to nan. Details: 
    Traceback (most recent call last):
    File "/Users/crystalcontreras/Desktop/DePaul/VulnerabilitiesResearch/vulnerability_detection/env38/lib/python3.8/site-packages/sklearn/model_selection/_validation.py", line 598, in _fit_and_score
        estimator.fit(X_train, y_train, **fit_params)
    File "/Users/crystalcontreras/Desktop/DePaul/VulnerabilitiesResearch/vulnerability_detection/env38/lib/python3.8/site-packages/sklearn/pipeline.py", line 346, in fit
        self._final_estimator.fit(Xt, y, **fit_params_last_step)
    File "/Users/crystalcontreras/Desktop/DePaul/VulnerabilitiesResearch/vulnerability_detection/env38/lib/python3.8/site-packages/keras/wrappers/scikit_learn.py", line 209, in fit
        return sup...

    [CV] END bgru__batch_size=32, bgru__dropout=0.1, bgru__epochs=15, bgru__maxlen=145, word2vec__alpha=0.01, word2vec__epochs=1, word2vec__negative=10, word2vec__sample=0.001, word2vec__seed=1, word2vec__vector_size=30, word2vec__window=5, word2vec__workers=2; total time= 3.0min
"""


class BGRUModel(BaseEstimator):
    def __init__(self, maxlen, units, epochs=10, layers=2, dropout=0.2, myoptimizer='adam', batch_size=32, vector_dim=30):
        self.bgru_model = None
        self.maxlen = maxlen
        self.units = units
        self.epochs = epochs
        self.vector_dim = vector_dim
        self.layers = layers
        self.dropout = dropout
        self.myoptimizer = myoptimizer
        self.batch_size = batch_size

    def fit(self, x, y=None): 
        print('Building model...')
        model = Sequential()
        model.add(Masking(mask_value=0.0, input_shape=(self.maxlen, self.vector_dim)))

        for i in range(1, self.layers):
            model.add(Bidirectional(GRU(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid', return_sequences=True)))
            model.add(Dropout(self.dropout))
        
        model.add(Bidirectional(GRU(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid')))
        model.add(Dropout(self.dropout))
        
        """            
            2D input of (batch_size, input_dim) would return (batch_size, units)
            For example, if our input is (25, 30), our output would be (25, 8)
        """
        model.add(Dense(self.units, activation='sigmoid'))
        
        """        
            TP_count = TruePositives()
            TN_count = TrueNegatives() 
            FP_count = FalsePositives() 
            FN_count = FalseNegatives()
            model.compile(loss='categorical_crossentropy', optimizer='sgd', metrics= ['accuracy', TP_count, TN_count, FP_count, FN_count])
            sgd = optimizers.SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True)
        """
        
        model.compile(loss='categorical_crossentropy', optimizer=self.myoptimizer, metrics=['accuracy'])
        model.summary()

        print('Fitting model...')

        train_generator = generator_of_data(x, y, self.batch_size, self.maxlen, self.vector_dim)   
        all_train_samples = len(x)
        steps_epoch = int(all_train_samples / self.batch_size)
        print(f'Length of dataset: {all_train_samples}.  Length of labels: {len(y)}')
        print("start")
        model.fit_generator(train_generator, steps_per_epoch=steps_epoch, epochs=self.epochs)

        self.bgru_model = model
    
        return self

    def predict(self, x):
        output_dl_labels = []
        predicted_labels = []
        reallabels = []

        if (len(x) == 1):#predict 1 program
            oneprogram = x[0]
            DL_labels = self.bgru_model.predict(x = tranfromInput(oneprogram , self.maxlen, self.vector_dim), batch_size=1)#for 1 program
        else:
            myarr = process_sequences_shape(x, self.maxlen, self.vector_dim)#predict 25 programs in files
            DL_labels = self.bgru_model.predict(x=myarr, batch_size=1)
        
        for l in DL_labels:
            output_dl_labels.append(l[0])
        print(output_dl_labels[0:10])
        predicted_labels = DL_labels
        for i in range(len(DL_labels)):
            if DL_labels[i] >= 0.5:
                predicted_labels[i] = 1
            else:
                predicted_labels[i] = 0
        totalPrograms  = len(x)
        print("predicted array shape: ", predicted_labels.shape)#numpy array (#totalprograms, 1) like (36,1) 36 rows 1 label columns
        #transform the real labels file to the same shape of predicted for model evaluation
        new_realLabel_array = np.reshape(reallabels, (totalPrograms,1))
        new_predicted_labels = np.reshape(predicted_labels, (totalPrograms,1))
        print("new real label array shape: " , new_realLabel_array.shape)
        
        myreallabelsList = []
        mypredlabelsList = []
        myoutputlabelsList = []
        for ele in new_realLabel_array:
            myreallabelsList.append(int(ele))
        for ele in output_dl_labels:
            myoutputlabelsList.append(float(ele))
        for ele in new_predicted_labels:
            mypredlabelsList.append(int(ele))

        d = {'TestID': data[-1], 'DLOutput':myoutputlabelsList, 'PredLabel': mypredlabelsList , 'RealLabel': myreallabelsList, 'Vtype': vtype_labels}
        df = pd.DataFrame(data=d)
        df.to_excel("OutputSummary_" + myoptimizer+ modelname + str(randomSeed) + ".xlsx")  
    
        return data[-1] , output_dl_labels, new_predicted_labels, new_realLabel_array, vtype_labels


