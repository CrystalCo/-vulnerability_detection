import os

import numpy as np
from keras.preprocessing import sequence
from keras.models import Sequential
from keras.layers.core import Masking, Dense, Dropout, Activation
from keras.layers.recurrent import GRU
from keras.layers.wrappers import Bidirectional

from utils.KerasClassifier import KerasClassifier

def create_bgru_model(maxlen=100, units2=2, vector_dim=30, layers=2, dropout=0.1, optimizer='adam'):
    print('\nBuild BGRU Model')
    model = Sequential()
    model.add(Masking(mask_value=0.0, input_shape=(maxlen, vector_dim)))
    for i in range(1, layers):
        model.add(Bidirectional(GRU(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid', return_sequences=True)))
        model.add(Dropout(dropout))
    model.add(Bidirectional(GRU(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid')))
    model.add(Dropout(dropout))
    model.add(Dense(units2, activation='sigmoid'))
    model.compile(loss='categorical_crossentropy', optimizer=optimizer, metrics=['accuracy'])
    model.summary()

    return model

def score(estimator, x, y):
    """
        Returns the mean accuracy on the given test data and labels.
        Args:
            x: array-like, shape `(n_samples, n_features)`
                Test samples where `n_samples` is the number of samples
                and `n_features` is the number of features.
            y: array-like, shape `(n_samples,)` or `(n_samples, n_outputs)`
                True labels for `x`.
            **kwargs: dictionary arguments
                Legal arguments are the arguments of `Sequential.evaluate`.
        Returns:
            score: float
                Mean accuracy of predictions on `x` wrt. `y`.
        Raises:
            ValueError: If the underlying model isn't configured to
                compute accuracy. You should pass `metrics=["accuracy"]` to
                the `.compile()` method of the model.
    """
    # y = np.searchsorted(self.classes_, y)
    # kwargs = self.filter_sk_params(Sequential.evaluate, kwargs)
    if type(estimator) != Sequential:
        return

    loss_name = estimator.loss
    if hasattr(loss_name, '__name__'):
        loss_name = loss_name.__name__
    if loss_name == 'categorical_crossentropy' and len(y.shape) != 2:
        y = to_categorical(y)

    outputs = estimator.evaluate(x, y)
    if not isinstance(outputs, list):
        outputs = [outputs]
    for name, output in zip(estimator.metrics_names, outputs):
        if name in ['accuracy', 'acc']:
            return output
    raise ValueError('The model is not configured to compute accuracy. '
                    'You should pass `metrics=["accuracy"]` to '
                    'the `model.compile()` method.')