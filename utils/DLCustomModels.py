from keras.models import Sequential
from keras.layers.core import Masking, Dense, Dropout
from keras.layers.recurrent import GRU, LSTM
from keras.layers.wrappers import Bidirectional

def create_bgru_model(maxlen=100, density=9, vector_dim=30, layers=2, dropout=0.1, optimizer='adam', activation='sigmoid', metrics=['categorical_accuracy']):
    print('\nBuild BGRU Model')
    model = Sequential()
    model.add(Masking(mask_value=0.0, input_shape=(maxlen, vector_dim)))
    for i in range(1, layers):
        model.add(Bidirectional(GRU(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid', return_sequences=True)))
        model.add(Dropout(dropout))
    model.add(Bidirectional(GRU(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid')))
    model.add(Dropout(dropout))
    model.add(Dense(density, activation=activation))
    model.compile(loss='categorical_crossentropy', optimizer=optimizer, metrics=metrics)
    model.summary()

    return model

def create_blstm_model(maxlen=100, density=9, vector_dim=30, layers=2, dropout=0.1, optimizer='adam', activation='sigmoid', metrics=['categorical_accuracy']):
    print('\nBuild model...')
    model = Sequential()
    model.add(Masking(mask_value=0.0, input_shape=(maxlen, vector_dim)))
    for i in range(1, layers):
        model.add(Bidirectional(LSTM(units=256, activation='sigmoid', recurrent_activation='sigmoid', use_bias=True, kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal', bias_initializer='zeros', unit_forget_bias=True, kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, recurrent_constraint=None, bias_constraint=None, dropout=0.0, recurrent_dropout=0.0, implementation=2, return_sequences=True, return_state=False, go_backwards=False, stateful=False, unroll=False)))
    model.add(Bidirectional(LSTM(units=256, activation='sigmoid', recurrent_activation='hard_sigmoid')))
    model.add(Dropout(dropout))
    model.add(Dense(density, activation=activation))          
    model.compile(loss='categorical_crossentropy', optimizer=optimizer, metrics=metrics)
    model.summary()
 
    return model    


