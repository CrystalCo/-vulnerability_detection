#!/usr/bin/env python
# coding: utf-8

# # Vulnerability Type Classification using DL
# Uses BGRU & BLSTM models to classify vulnerability type
# Categories contain non-vulnerable samples as well

# ### Setting variables
import os, sys
vType = "ALL"
randomSeed = 1099
numSamples = 420627 #Max Num of slice samples from each file
vectorDim = 30 #num of vector cols
slicePath = os.path.join('data','slicesSource')
tokenPath = os.path.join('data','token','SARD')
multiclasspath = os.path.join('data','CVE','SARD_CVE_to_groups.csv')
w2vmodelPath = os.path.join('w2vModel','model','w2vModel_ALL')
vectorPath = os.path.join('data','vector')
vectorTypePath = os.path.join('data','DLvectors')
vectorTrainPath = os.path.join(vectorTypePath,'train')
vectorTestPath = os.path.join(vectorTypePath,'test')
dlInputsTrainPath = os.path.join('data','DLinputs','train')
dlInputsTestPath  = os.path.join('data','DLinputs','test')

VUL_PATH = os.environ.get('VUL_PATH')
sys.path.insert(1, VUL_PATH)


# ### A. slicesToTokens.py
# from SYSE_1_isVulnerable.slicesToTokens import tokenizeSlices_Multiclass
# testcase_ids, testcase_ids_per_group = tokenizeSlices_Multiclass(slicePath, tokenPath, multiclasspath, numSamples)


# # # ### B.  isDuplicatedID.py
# from SYSE_1_isVulnerable.isDuplicatedID import isDuplicatedID
# print("The dataset has duplicated ID: ", isDuplicatedID(testcase_ids))

# ### C. tokensToVectors.py
# from SYSE_1_isVulnerable.tokensToVectors import createW2VModel, fitW2VModel
# myW2Vmodel = createW2VModel(w2vmodelPath, tokenPath, vectorDim)
# fitW2VModel(w2vmodelPath, tokenPath, vectorPath)


### Combine data into 1 file
from utils.combineVectors import combine_vectors_from_files
combine_vectors_from_files(vectorPath, vectorTypePath, randomSeed=randomSeed)

"""
from utils.utils import getDataset
all_data = getDataset(vectorTypePath, False)


# ### E. Get number of unique classes for density value
from utils.utils import num_classes, encode_target
categories = num_classes(vectorTrainPath)
num_units = len(categories)
mapping, labelEncoder = encode_target(categories)

# ### F. adjustVectorLen.py - Ensure each program (aka slice) contains the same amount of rows (i.e. tokens) in the data matrix.
from SYSE_1_isVulnerable.adjustVectorLen import meanLen, tranformVectorLen
avg = meanLen(vectorTrainPath, 'ALL')
# tranformVectorLen(vectorTrainPath, vectorTestPath, dlInputsTrainPath, dlInputsTestPath, avg, vectorDim, vType)
# print(f'New Vector Length (rows x cols): {avg} x {vectorDim}\n')

# # # ### G. saveKeyData.py - Used to fit BGRU model.
# from SYSE_1_isVulnerable.saveKeyData import saveKeyDataMulticlass
# saveKeyDataMulticlass(dlInputsTrainPath, labelEncoder)
# saveKeyDataMulticlass(dlInputsTestPath, labelEncoder)


# ### H. DLModel.py
import tensorflow as tf
from tensorflow import keras
from SYSE_1_isVulnerable.DLModel import buildBGRU2, buildBLSTM2, fitModel2
myoptimizer = 'adam' #can be changed to ‘adamax’
maxlen = avg #avg calculated from part 5.6
layers = 2
dropout = 0.2 
batchSize = 32
vectorDim = 30

# ### Network Architechture
# ### Part A: BGRU
import time
t1 = time.time()
print(f'\nDL MODELS - START: {t1}\n')

# Create MirroredStrategy for Single-host, multi-device (GPU) synchronous training
strategy = tf.distribute.MirroredStrategy()
print("\nNumber of devices: {}".format(strategy.num_replicas_in_sync))


# Open a strategy scope
with strategy.scope():
    #Build BGRU Model with parameters 
    myKerasModel =  buildBGRU2(maxlen, vectorDim, layers, dropout, myoptimizer, num_units)

#Fit BGRU Model with trained data and saved the model for later use
weightpath = './model/BRGU_ALL' + myoptimizer +str(randomSeed)
mymodel = fitModel2(myKerasModel, weightpath, dlInputsTrainPath, batchSize, maxlen, vectorDim, randomSeed)



# ### Part B: BLSTM
print("\nNumber of devices: {}".format(strategy.num_replicas_in_sync))

# Open a strategy scope
with strategy.scope():
    #Build BLSTMModel with parameters 
    myKerasModel =  buildBLSTM2(maxlen, vectorDim, layers, dropout, myoptimizer, num_units)

#Fit BLSTM Model with trained data and saved the model for later use
weightpath = './model/BLSTM_ALL' + myoptimizer +str(randomSeed)
mymodel = fitModel2(myKerasModel, weightpath, dlInputsTrainPath, batchSize, maxlen, vectorDim, randomSeed)



# ### I. DLPrediction.py
#all parameters are same as section 5.8
from SYSE_1_isVulnerable.DLPrediction import predictMulticlassLabel
myoptimizer = 'adam'
maxlen = avg
layers = 2
dropout = 0.2 
batchSize = 32


# #### Input: 	
# - final test set and saved model
# 
# #### Output:   
# - output values and predicted values from Model saved to excel file: OutputSummary_adamRandomseed.xlsx

# ### Part A: BGRU
modelName = 'BGRU'
weightpath = './model/BRGU_ALL' + myoptimizer +str(randomSeed)
print("\nNumber of devices: {}".format(strategy.num_replicas_in_sync))
# Open a strategy scope
with strategy.scope():
    myKerasModelADAM =  buildBGRU2(maxlen,vectorDim, layers, dropout,myoptimizer, num_units)
myKerasModelADAM.load_weights(weightpath)
thresholds_dl_labels, mypredicted_labels, myreallabels  = predictMulticlassLabel(myKerasModelADAM, dlInputsTestPath, maxlen, vectorDim, myoptimizer, modelName, randomSeed, labelEncoder)


# ### Part B: BLSTM
modelName = 'BLSTM'
weightpath = './model/BLSTM_ALL' + myoptimizer +str(randomSeed)
print("\nNumber of devices: {}".format(strategy.num_replicas_in_sync))
# Open a strategy scope
with strategy.scope():
    myKerasModelADAM2 =  buildBLSTM2(maxlen,vectorDim,layers,dropout,myoptimizer, num_units)
myKerasModelADAM2.load_weights(weightpath)
thresholds_dl_labels2, mypredicted_labels2, myreallabels2  = predictMulticlassLabel(myKerasModelADAM2, dlInputsTestPath, maxlen, vectorDim, myoptimizer, modelName, randomSeed, labelEncoder)

t2 = time.time()
print(f'\nDL MODELS - END: {t2}')
print('Total Minutes: ', (t2-t1)/60)
# ## J. ConfusionMatrix.py

# #### Input: 	
# - predicted label and real label from part I
# 
# #### Output:   
# - confusion matrix 

# Confusion matrix for each category.
from SYSE_1_isVulnerable.ConfusionMatrix import getConfusionMatrix_Multiclass
acc, micro_precision, micro_recall, micro_f1, macro_precision, macro_recall, macro_f1, weighted_precision, weighted_recall, weighted_f1 = getConfusionMatrix_Multiclass(mypredicted_labels, myreallabels)#BGRU

acc, micro_precision, micro_recall, micro_f1, macro_precision, macro_recall, macro_f1, weighted_precision, weighted_recall, weighted_f1 = getConfusionMatrix_Multiclass(mypredicted_labels2, myreallabels2)#BLSTM


# # Output Analysis
import pandas as pd

fileName = "OutputSummary_adamBGRU1099.xlsx"
DLdata = pd.read_excel(fileName)
print("\nADAM BGUR Output Summary:\n", DLdata.head(10))


# ## K. evaluateModels.py
from SYSE_1_isVulnerable.evaluateModels import roc_auc_score_multiclass
roc_auc_dict = roc_auc_score_multiclass(myreallabels, mypredicted_labels)
print('\nROC AUC Score - BGRU\n', roc_auc_dict)
roc_auc_dict = roc_auc_score_multiclass(myreallabels2, mypredicted_labels2)
print('\nROC AUC Score - BLSTM\n', roc_auc_dict)


# ## L. plotCounts.py
import matplotlib.pyplot as plt
from SYSE_1_isVulnerable.plotCounts import plotHistogram, plotBar
colName = "Metric0.5"
mydata = mydata

plt.clf()
plotHistogram(mydata, colName, True)
plt.clf()
plotBar(mydata, colName, True)
plt.clf()


myTable = generateMetricTabel(thresdArray, recall, precision, specificity, F1, Accuracy, balanceAccuracy)
print(myTable)


# ## Appendix A : Plot Recall VS Precision 
import matplotlib.pyplot as plt
plt.scatter(precision, recall, color='blue')
plt.plot(precision, recall, color='blue')
plt.xlabel('precision')
plt.ylabel('recall')
plt.title('Recall VS Precision')
plt.legend()
plt.savefig('./data/plots/recallVsPrecision.png')
plt.clf()

# ## Appendix B : Plot F1, balancedAccuracy with Different Threshold
plt.scatter(thresdArray, F1, color='orange')
plt.plot(thresdArray, F1, color='orange', label="F1")
plt.scatter(thresdArray,balanceAccuracy, color='purple')
plt.plot(thresdArray, balanceAccuracy, color='purple', label="balanceAccuracy")
plt.xlabel('Threshold')
plt.ylabel('Rate')
plt.title('Metrics with Different Threshold')
plt.legend()
plt.savefig('./data/plots/f1.png')
plt.clf()

# ## Appendix C : Plot Accuracy, balancedAccuracy with Different Thresholds
plt.scatter(thresdArray,balanceAccuracy, color='purple')
plt.plot(thresdArray, balanceAccuracy, color='purple', label="balanceAccuracy")
plt.scatter(thresdArray,Accuracy, color='pink')
plt.plot(thresdArray, Accuracy, color='pink', label="Accuracy")
plt.xlabel('Threshold')
plt.ylabel('Rate')
plt.title('Metrics with Different Threshold')
plt.legend()
plt.savefig('./data/plots/balancedAccuracy.png')
plt.clf()

# ## Appendix D : Plot Accuracy, Specificity with Different Thresholds
plt.scatter(thresdArray,specificity, color='blue')
plt.plot(thresdArray, specificity, color='blue', label="specificity")
plt.scatter(thresdArray,Accuracy, color='pink')
plt.plot(thresdArray, Accuracy, color='pink', label="Accuracy")
plt.xlabel('Threshold')
plt.ylabel('Rate')
plt.title('Metrics with Different Threshold')
plt.legend()
plt.savefig('./data/plots/specificity.png')
plt.clf()
"""