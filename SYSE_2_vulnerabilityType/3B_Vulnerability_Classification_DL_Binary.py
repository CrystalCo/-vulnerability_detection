#!/usr/bin/env python
# coding: utf-8

# # Vulnerability Type Classification using DL
# Uses BGRU & BLSTM models to classify vulnerability type

# ### Setting variables
import os, sys
vType = "ALL" # what to subsample from
randomSeed = 1099
numSamples = 420627  # Max Num of slice samples from each file
vectorDim = 30 #num of vector cols
testcase_ids_per_group = None
slicePath = './data/slicesSource/'
tokenPath = './data/token/SARD/'
w2vmodelPath = './w2vModel/model/w2vModel_ALL'
vectorPath =  './data/vector/'
multiclasspath = './data/CVE/SARD_CVE_to_groups.csv'
# Training & testing split, where training is balanced & testing is not
vectorTrainPath = './data/DLvectors/train/'
vectorTestPath = './data/DLvectors/test/'
# Balanced Train & Test sets with same length vectors for DL models
dlInputsTrainPath = './data/DLinputs/train/'
dlInputsTestPath  = './data/DLinputs/test/'

VUL_PATH = os.environ.get('VUL_PATH')
sys.path.insert(1, VUL_PATH)

"""
# ### A. slicesToTokens.py
from SYSE_1_isVulnerable.slicesToTokens import tokenizeSlices_Multiclass
mycase_ID, testcase_ids_per_group = tokenizeSlices_Multiclass(slicePath, tokenPath, multiclasspath, numSamples)

# ### B.  isDuplicatedID.py
from SYSE_1_isVulnerable.isDuplicatedID import isDuplicatedID
print("The dataset has duplicated ID: ", isDuplicatedID(mycase_ID))


# ### C. tokensToVectors.py
from SYSE_1_isVulnerable.tokensToVectors import createW2VModel, fitW2VModel
myW2Vmodel = createW2VModel(w2vmodelPath, tokenPath, vectorDim)
fitW2VModel(w2vmodelPath, tokenPath, vectorPath)
"""

# ### D. splitTrainTest.py
from SYSE_1_isVulnerable.splitTrainTest import splitTrainTestCategorical
if testcase_ids_per_group is not None:
    #faster
    splitTrainTestCategorical(vType, vectorPath, vectorTrainPath, vectorTestPath, randomSeed, testcase_ids_per_group[int(vType)], split=0.8)
else:
    splitTrainTestCategorical(vType, vectorPath, vectorTrainPath, vectorTestPath, randomSeed, split=0.8)


# ### E. downSampling.py
from SYSE_1_isVulnerable.downSampling import appendCaseIDLabel0, downsampling, isClassBalanced
caseID_one, caseID_zero, downsampleNum = appendCaseIDLabel0(vectorTrainPath, vType)
downsampling(caseID_one, caseID_zero, downsampleNum, randomSeed, vectorPath, vectorTrainPath)
# Optional used to check if the class label are balanced 
print("Class Labels are balanced: %s\n" % isClassBalanced(vectorTrainPath))


# ### F. adjustVectorLen.py
# Ensure each program (aka slice) contains the same amount of rows (i.e. tokens) in the data matrix.
from SYSE_1_isVulnerable.adjustVectorLen import meanLen, tranformVectorLen
avg = meanLen(vectorTrainPath)
tranformVectorLen(vectorTrainPath, vectorTestPath, dlInputsTrainPath, dlInputsTestPath, avg, vectorDim, vType)
print(f'New Vector Length (rows x cols): {avg} x {vectorDim}\n') # data/DLinputs/test/DL_Final_...pkl


# ### G. saveKeyData.py
# Used to fit BGRU model.
from SYSE_1_isVulnerable.saveKeyData import saveKeyData
saveKeyData(dlInputsTrainPath)
saveKeyData(dlInputsTestPath)


# ### H. DLModel.py
from SYSE_1_isVulnerable.DLModel import buildBGRU, buildBLSTM, fitModel
myoptimizer = 'adam' #can be changed to ‘adamax’
maxlen = avg #avg calculated from part 5.6
layers = 2
dropout = 0.2 
batchSize = 32
vectorDim = 30



# ### Network Architechture
# ### Part A: BGRU
#Build BGRU Model with parameters 
myKerasModel =  buildBGRU(maxlen, vectorDim, layers, dropout, myoptimizer)

#Fit BGRU Model with trained data and saved the model for later use
weightpath = './model/BRGU_ALL' + myoptimizer +str(randomSeed)
mymodel = fitModel(myKerasModel, weightpath, dlInputsTrainPath, batchSize, maxlen, vectorDim, randomSeed)


# ### Part B: BLSTM
#Build BLSTMModel with parameters 
myKerasModel =  buildBLSTM(maxlen, vectorDim, layers, dropout,myoptimizer )

#Fit BLSTM Model with trained data and saved the model for later use
weightpath = './model/BLSTM_ALL' + myoptimizer +str(randomSeed)
mymodel = fitModel(myKerasModel, weightpath, dlInputsTrainPath, batchSize, maxlen, vectorDim, randomSeed)



# ### I. DLPrediction.py
#all parameters are same as section 5.8
from SYSE_1_isVulnerable.DLPrediction import predictLabel
myoptimizer = 'adam'
maxlen = avg
layers = 2
dropout = 0.2 
batchSize = 32


# #### Input: 	
# - final test set and saved model
# 
# #### Output:   
# - output values and predicted values from Model saved to excel file: OutputSummary_adamRandomseed.xlsx

# ### Part A: BGRU
modelName = 'BGRU'
weightpath = './model/BRGU_ALL' + myoptimizer +str(randomSeed)
myKerasModelADAM =  buildBGRU(maxlen,vectorDim, layers, dropout, myoptimizer)
myKerasModelADAM.load_weights(weightpath)
testID_label, output_dl_labels, mypredicted_labels, myreallabels, myvtypelabels  = predictLabel(myKerasModelADAM, dlInputsTestPath, maxlen, vectorDim, myoptimizer, modelName, randomSeed)


# ### Part B: BLSTM
modelName = 'BLSTM'
weightpath = './model/BLSTM_ALL' + myoptimizer +str(randomSeed)
myKerasModelADAM2 =  buildBLSTM(maxlen,vectorDim,layers,dropout,myoptimizer )
myKerasModelADAM2.load_weights(weightpath)
testID_label2, output_dl_labels2, mypredicted_labels2, myreallabels2, myvtypelabels  = predictLabel(myKerasModelADAM2, dlInputsTestPath, maxlen, vectorDim, myoptimizer, modelName, randomSeed)


# ## J. ConfusionMatrix.py

# #### Input: 	
# - predicted label and real label from part I
# 
# #### Output:   
# - confusion matrix 

from SYSE_1_isVulnerable.ConfusionMatrix import getConfusionMatrix
getConfusionMatrix(mypredicted_labels, myreallabels)#BGRU
getConfusionMatrix(mypredicted_labels2, myreallabels2)#BLSTM



# # Output Analysis
##  From Jupyter Notebook. Needs to be modified to output plots to files.

import numpy as np
import pandas as pd
import os

fileName = "OutputSummary_adamBGRU1099.xlsx"
DLdata = pd.read_excel(fileName)
print("\nADAM BGUR Output Summary:\n", DLdata.head(10))


# import seaborn as sns

# sns.set(rc={'figure.figsize':(11.7,8.27)})
# ax = sns.boxplot(x="Vtype", y='DLOutput', hue='RealLabel', data=DLdata, linewidth=1.5, palette="Set3")


# ## K. evaluateModels.py
from SYSE_1_isVulnerable.evaluateModels import combinedPredictions, generateMetricTabel, predictValueWithThreshold
thresdArray = [0.40, 0.45,0.5, 0.53, 0.55, 0.58, 0.60, 0.65, 0.70, 0.8]
mydata, recall, precision, specificity, F1, Accuracy, balanceAccuracy  = combinedPredictions(thresdArray, DLdata)
mydata.to_excel("predictionWithDiffThreshold_gruadam.xlsx")  
print("\nADAM GRU Predictions with Different Thresholds:\n", mydata.head(10))


# ## L. plotCounts.py
from SYSE_1_isVulnerable.plotCounts import plotHistogram, plotBar
colName = "Metric0.5"
mydata = mydata

plotHistogram(mydata, colName, True)
plotBar(mydata, colName, True)


myTable = generateMetricTabel(thresdArray, recall, precision, specificity, F1, Accuracy, balanceAccuracy)
print(myTable)


# ## Appendix A : Plot Recall VS Precision 
import matplotlib.pyplot as plt
plt.scatter(precision, recall, color='blue')
plt.plot(precision, recall, color='blue')
plt.xlabel('precision')
plt.ylabel('recall')
plt.title('Recall VS Precision')
plt.legend()
plt.savefig('./data/plots/recallVsPrecision.png')
plt.clf()


# ## Appendix B : Plot F1, balancedAccuracy with Different Threshold
plt.scatter(thresdArray, F1, color='orange')
plt.plot(thresdArray, F1, color='orange', label="F1")
plt.scatter(thresdArray,balanceAccuracy, color='purple')
plt.plot(thresdArray, balanceAccuracy, color='purple', label="balanceAccuracy")
plt.xlabel('Threshold')
plt.ylabel('Rate')
plt.title('Metrics with Different Threshold')
plt.legend()
plt.savefig('./data/plots/f1.png')
plt.clf()


# ## Appendix C : Plot Accuracy, balancedAccuracy with Different Thresholds
plt.scatter(thresdArray,balanceAccuracy, color='purple')
plt.plot(thresdArray, balanceAccuracy, color='purple', label="balanceAccuracy")
plt.scatter(thresdArray,Accuracy, color='pink')
plt.plot(thresdArray, Accuracy, color='pink', label="Accuracy")
plt.xlabel('Threshold')
plt.ylabel('Rate')
plt.title('Metrics with Different Threshold')
plt.legend()
plt.savefig('./data/plots/balancedAccuracy.png')
plt.clf()


# ## Appendix D : Plot Accuracy, Specificity with Different Thresholds
plt.scatter(thresdArray,specificity, color='blue')
plt.plot(thresdArray, specificity, color='blue', label="specificity")
plt.scatter(thresdArray,Accuracy, color='pink')
plt.plot(thresdArray, Accuracy, color='pink', label="Accuracy")
plt.xlabel('Threshold')
plt.ylabel('Rate')
plt.title('Metrics with Different Threshold')
plt.legend()
plt.savefig('./data/plots/specificity.png')
plt.clf()

