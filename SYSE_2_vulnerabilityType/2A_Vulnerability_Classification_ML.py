#!/usr/bin/env python
# coding: utf-8

# # Vulnerability Type Classification using ML
# The following models will be used to see which one performs best when attempting to classify a vulnerability type in a program:
# - K-Nearest Neighbors (KNN)
# - Random Forest Classifier (RFC)
# - Linear Support Vector Classifer (LinearSVC)

# ## Setting Variables

import os, sys

from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import LinearSVC

VUL_PATH = os.environ.get('VUL_PATH')
sys.path.insert(1, VUL_PATH)

from utils.MetricsEvaluationLib import getConfusionMatrix_Multiclass
from SYSE_2_vulnerabilityType.DetectVulType import DetectVulType
from utils.utils import getDataset
from utils.MLMethods import predict_and_score

RANDOMSEED = 1099
CLASS_TYPE = 'Granular_162'
VECTOR_TRANSFORMER='w2v'
MODEL_TYPE = 'linearSVC'

vectorRootPath = os.path.join('data', 'DLvectors')
vectorTrainPath_flat = os.path.join(vectorRootPath,'train_162classes_flattened')
vectorTestPath_flat = os.path.join(vectorRootPath,'test_162classes_flattened')
dlInputs = os.path.join('data', 'DLinputs')
dlInputsTrainPath_flat = os.path.join(dlInputs,'train_162classes_flattened')
dlInputsTestPath_flat = os.path.join(dlInputs,'test_162classes_flattened')

metrics_path = os.path.join(f'metrics', MODEL_TYPE)
model_name = '%s_%s_seed=%s_%s' % (MODEL_TYPE.upper(), VECTOR_TRANSFORMER.upper(), RANDOMSEED, CLASS_TYPE)

dvt = DetectVulType(build_model=LinearSVC, randomSeed=RANDOMSEED, vectorTrainPath=vectorTrainPath_flat)
dvt.encodeLabels()

# Get train/test sets
data = getDataset(vectorTrainPath_flat, RANDOMSEED=RANDOMSEED)
x_train = data[0]
y_train = data[-2]
assert len(x_train[0]) == len(x_train[-1]), f'vector lengths dont match in x_train. {len(x_train[0])} != {len(x_train[-1])}'

data = getDataset(vectorTestPath_flat, RANDOMSEED=RANDOMSEED)
x_test = data[0]
y_test = data[-2]
assert len(x_test[0]) == len(x_test[-1]), f'vector lengths dont match in x_test. {len(x_test[0])} != {len(x_test[-1])}'

print(f'Length of x_train: {len(x_train)}\nLength of columns: {len(x_train[0])}')
print(f'\nLength of x_test: {len(x_test)}\nLength of columns: {len(x_test[0])}')
print(f'y_test[:3]:\n{y_test[:3]}\nNumber of labels: {len(y_test)}')

assert len(x_train[0]) == len(x_test[0]), f'Feature length of x_train {len(x_train[0])} should match that of x_test {len(x_test[0])}'



##### Linear Support Vector Classifier
print('\nCommencing LinearSVC')
MODEL_TYPE = 'linearSVC'
metrics_path = os.path.join(f'metrics', MODEL_TYPE)
model_name = '%s_%s_seed=%s_%s' % (MODEL_TYPE.upper(), VECTOR_TRANSFORMER.upper(), RANDOMSEED, CLASS_TYPE)
linearSVC = LinearSVC(C=5, dual=False, class_weight='balanced', verbose=1).fit(x_train, y_train)
y_pred = predict_and_score(linearSVC, 'Linear Support Vector Classifier', x_test, y_test, 'test')

# Performance Metrics
getConfusionMatrix_Multiclass(y_pred, y_test, path=metrics_path, modelName=model_name)




"""
##### Random Forest Classifier
print('\nCommencing RF')
MODEL_TYPE = 'rfc'
metrics_path = os.path.join(f'metrics', MODEL_TYPE)
model_name = '%s_%s_seed=%s_%s' % (MODEL_TYPE.upper(), VECTOR_TRANSFORMER.upper(), RANDOMSEED, CLASS_TYPE)
rfc = RandomForestClassifier(max_features=None, n_estimators=300, criterion='entropy', 
                            max_depth=15, max_samples=0.8, min_samples_leaf=2, 
                            min_samples_split=3, n_jobs=-1, random_state=RANDOMSEED,
                            class_weight='balanced').fit(x_train, y_train)
y_pred = predict_and_score(rfc, 'Random Forest Classifier', x_test, y_test, 'test')

# Convert back to original labels
decoded_y_test = dvt.labelEncoder.inverse_transform(y_test)
decoded_y_pred = dvt.labelEncoder.inverse_transform(y_pred)
assert decoded_y_pred.shape == decoded_y_test.shape, f'Predicted array shape {decoded_y_pred.shape} should match True label array shape {decoded_y_test.shape}'

# Performance Metrics
getConfusionMatrix_Multiclass(decoded_y_pred, decoded_y_test, saveFig=True, path=metrics_path, modelName=model_name)


#### K-Nearest Neighbors
print('\nCommencing KNN')
MODEL_TYPE = 'knn'
knn = KNeighborsClassifier(n_neighbors=4, 
                            weights='distance', 
                            p=2,
                            n_jobs=-1).fit(x_train, y_train)
y_pred = predict_and_score(knn, 'KNN', x_test, y_test, 'test')

# Convert back to original labels
decoded_y_test = dvt.labelEncoder.inverse_transform(y_test)
decoded_y_pred = dvt.labelEncoder.inverse_transform(y_pred)
assert decoded_y_pred.shape == decoded_y_test.shape, f'Predicted array shape {decoded_y_pred.shape} should match True label array shape {decoded_y_test.shape}'

# Performance Metrics
getConfusionMatrix_Multiclass(decoded_y_pred, decoded_y_test, saveFig=True, path=metrics_path, modelName=model_name)
"""
