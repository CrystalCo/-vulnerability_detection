import requests
import pandas as pd
from queue import Queue
from Node import Node

"""
    Methods used in 2_Clustering_By_Abstraction.ipynb to create a hierarchical tree of CWE relationships.
"""

def create_cwe_node(cwe_id, df):
    df_copy = df.set_index(['CWE_ID'])
    node = Node(cwe_id)
    node.name = df_copy.loc[cwe_id]['Name']
    node.abstraction = df_copy.loc[cwe_id]['Abstraction']
    return node

def create_category_nodes(categories, df, nodes):
    """
        Creates new nodes for high level groups not found in Research Concepts.
        categories := array of ints representing CWE IDs
        df := expects CWE dataframe where all the cwe info per node exists
        nodes := dictionary of nodes
    """
    for cwe in categories:
        node = Node(cwe)
        node.abstraction = 'Category'
        node.active = True
        node.name = df.loc[cwe, 'Name']
        node.count = df.loc[cwe, 'cwe_count']
        assign_cat_to_pillar(node, nodes)
        # No need to call flag_active() since no branches exist.
        nodes[cwe] = node

def assign_cat_to_pillar(node, nodes):
    """
        Hard coding category nodes to pillar nodes based on their descriptions,
        to avoid redundant groupings and that way all nodes fall under a single view - Research Concepts.
    """
    pnode = 0 
    if node.id == 189:
        pnode = 682
    elif node.id == 310:
        pnode = 693
    elif (node.id == 255) or (node.id == 254):
        pnode = 284
    elif node.id == 398:
        pnode = 710
    elif node.id == 399:
        pnode = 664
    else:
        print(f'{node.id} missing parent assignment.')
        
    node.parents.append(nodes[pnode])
    nodes[pnode].children.append(node) 

def parse_parents(related):
    """
        INPUT:
            related := String. Contains the relationships of a CWE. 
                        Example, "::NATURE:ChildOf:CWE ID:828:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:663:VIEW ID:1000::NATURE:CanPrecede:CWE ID:123:VIEW ID:1000::"

        OUTPUT:
            an array of 0 or 1 integers.  Integers represent the parent ID. If none, means no parent (aka must be a top-level group)
    """
    split_related = related.split('::')[1:-1] # Remove whitespaces at beginning and end
    childOf = [x for x in split_related if ('ChildOf' in x) and ('VIEW ID:1000' in x) and ('ORDINAL:Primary' in x)]
    parent = []
    if len(childOf) == 1:
        cwe_id = int(childOf[0].split(':')[3])
        parent.append(cwe_id)
    elif len(childOf) > 1:
        print(f'WARNING: More than one parent found for CWE-{cwe_id}!!')
    return parent
    
def assign_relationships(nodes):
    for nid in nodes:
        node = nodes[nid]
        # assign parents to node
        if len(node.parents) > 2:
            print(f'WARNING!  More than 1 parent node found in CWE-{node.id}')
        elif len(node.parents) == 1:
            pid = node.parents.pop()
            node.parents = []
            node.parents.append(nodes[pid])
            # assign children
            if node in nodes[pid].children:
                print(f'WARNING: potential duplicate CWE-{node.id} b/c node was already in parents children array. Parent ID-{pid}')
            else:
                nodes[pid].children.append(node)

def create_nodes_dict(df):
    # Create dictionary holding all vertices (aka nodes)
    nodes = dict()

    for i, row in df.iterrows():
        cwe_id = row['CWE_ID']
        if cwe_id not in nodes:
            # create new node to add to dictionary
            node = create_cwe_node(cwe_id, df)
            related = row['Relationships']
            # get parents if applicable. rows with strings contain relationships.  rows w/NaN or empty are most likely top-level group (e.g. Pillars)
            if type(related) == str:
                parents = parse_parents(related)  # returns an array with either 1 or 0 integers.  Later will update with actual reference to parent node in assign_relationships().
                node.parents = parents          # technically not overwriting since this will be the first pass                
            nodes[cwe_id] = node
        else:
            print(f'Duplicate node detected in data! CWE-{cwe_id}')
                                    
    return nodes

def flag_active(node, nodes):
    if node.parents == []:
        return
    for parent in node.parents:
        cwe_id = parent.id
        nodes[cwe_id].active = True
        flag_active(nodes[cwe_id], nodes)

def add_counts(df, nodes):
    """
        Takes the counts from our cwe_df table, insert them into our nodes dictionary, & 'activates' the node (for printing purposes).
        Returns:
            - nodes dict with updated count & active flag, 
            - a list of missing cwes that were not in the nodes dictionary.
    """
    cwes_missing = []

    for i, row in df.iterrows():

        if i in nodes:
            nodes[i].count = row['cwe_count']
            nodes[i].active = True
            flag_active(nodes[i], nodes)
        else:
            cwes_missing.append(i)
    return nodes, cwes_missing

def get_top_level(nodes):
    """
        Returns an array of Pillar & Category nodes.
        Has its own function because Pillars & Categories are not an abstraction, 
        and therefore do not contain the root in their relationship column.
    """
    groups = []
    for n_id in nodes:
        node = nodes[n_id]
        if (node.abstraction == 'Pillar'):
            groups.append(node)
    return groups

def get_groups_by_relationship(groups_array):
    """
        Creates a dictionary with group ids as the keys and an array of cwe ids within that group as the value.
    """
    groups_by_relationship = dict()
    
    for group in groups_array:
        q = Queue()
        q.put(group)
        explored = set()

        groups_by_relationship[group.id] = []

        while not q.empty():
            node = q.get()
            explored.add(node) # Avoids risk of duplicate counts (e.g. CWE-122 is a child of both CWE-787 & CWE-788)           
            groups_by_relationship[group.id].append(node.id)

            for child in node.children:
                if child not in explored:
                    q.put(child)

    return groups_by_relationship

def set_groupid_to_nodes(nodes, groups_by_relationship):
    for key in groups_by_relationship:
        val = groups_by_relationship[key]
        for v in val:
            if nodes[v].group_id != None:
                raise Exception(f'Should not have a node that already has a group id.  Group ID {key} for node ID {v}.  There must be a duplicate.')
            else:
                nodes[v].group_id = key

def test_case_id_to_group_id(df, nodes, obsolete_ids):
    """
        INPUT:
            df := the cwe dataframe (cwe_df)
            nodes := the cwe nodes dictionary
            obsolete_ids := array of integers that represent CWE IDs that are deprecated or obsolete

        OUTPUT:
            Returns a dictionary with the original SARD/CVE ID as the key, and their CWE's group id as the value.
    """
    cases_dict = dict()

    for key, val in df.iterrows():
        if key in obsolete_ids:
            continue
            
        og_ids = df.loc[key, 'original_ids'].split(' ')
        for oid in og_ids:
            cases_dict[oid] = nodes[key].group_id
            
    return cases_dict

def get_group_sum(groups_array):
    """
        Gets the sum of all the examples per group.
        Returns an array of tuples in the form (group ID + group name, sum), 
        and an array of tuples that contain duplicate nodes (i.e. nodes found in multiple groups)
    """
    group_sum = [] # array of tuples 
    # Find which nodes are in other groups 
    global_explored = set() # Avoids risk of duplicate counts for CWEs contained in other groups
    global_explored_arr = []
    
    for group in groups_array:
        count = 0
        name = 'CWE-%d: %s' % (group.id, group.name)

        q = Queue()
        q.put(group)
        explored = set()
        
        while not q.empty():
            node = q.get()
            explored.add(node) # Avoids risk of duplicate counts (e.g. CWE-122 is a child of both CWE-787 & CWE-788)
            if node in global_explored and node.count > 0:
                global_explored_arr.append((name, node.id, node.name, node.count))
            else:
                global_explored.add(node)
                count += node.count
            
            for child in node.children:
                if child not in explored:
                    q.put(child)
        
        group_sum.append((name, count))
        
    return group_sum, global_explored_arr
