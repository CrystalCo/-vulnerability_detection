import os
import pickle
import numpy as np
import pandas as pd
from SYSE_1_isVulnerable.preprocess_dl_Input_version5 import *
from utils.utils import get_predicted_class_and_accuracy


def tranfromInput (onevectorsample, maxlen,vecdim):
    nb_samples = np.zeros((1, maxlen, vecdim))
    sequence = onevectorsample

    i = 0
    m = 0
    for vectors in sequence:#500
        n = 0
        for values in vectors:#30
            nb_samples[i][m][n] += values
            n += 1
        m += 1
         
    print(np.shape(nb_samples))
    return nb_samples


def predictLabel(mymodel, testpath, maxlen, vecdim, myoptimizer, modelname, randomSeed):
    dataset = []
    testIDs = []
    reallabels = []
    predicted_labels = []
    output_dl_labels = []
    vtype_labels = []
    for filename in os.listdir(testpath):#"./data/DLInputs/test/"
        if filename.endswith(".pkl"):
            f = open(os.path.join(testpath, filename),"rb")
            data = pickle.load(f)
            f.close()
            dataset += data[0]
            reallabels += data[1]
            vtype_labels += data[4]
            testIDs += data[-1] 
    if (len(dataset) == 1):#predict 1 program
        oneprogram = dataset[0]
        DL_labels = mymodel.predict(x = tranfromInput(oneprogram , maxlen, vecdim),batch_size = 1)#for 1 program

    else:
        myarr = process_sequences_shape(dataset, maxlen, vecdim)#predict 25 programs in files
        DL_labels = mymodel.predict(x = myarr ,batch_size = 1)
    
    for l in DL_labels:
        output_dl_labels.append(l[0]) # flattens array or arrays
    print(output_dl_labels[0:10])
    predicted_labels = DL_labels # makes a copy of DL_labels to be modified from float to int prediction of 1 or 0
    for i in range(len( DL_labels)):
        if DL_labels[i]>= 0.5:
            predicted_labels[i] = 1
        else:
            predicted_labels[i] = 0
    totalPrograms  = len(dataset)
    print("predicted array shape: ", predicted_labels.shape)#numpy array (#totalprograms, 1) like (36,1) 36 rows 1 label columns
    #transform the real labels file to the same shape of predicted for model evaluation
    new_realLabel_array = np.reshape(reallabels, (totalPrograms,1))
    new_predicted_labels = np.reshape(predicted_labels, (totalPrograms,1))
    print("new real label array shape: " , new_realLabel_array.shape)
    
    myreallabelsList = []
    mypredlabelsList = []
    myoutputlabelsList = []
    for ele in new_realLabel_array:
        myreallabelsList.append(int(ele))
    for ele in output_dl_labels:
        myoutputlabelsList.append(float(ele))
    for ele in new_predicted_labels:
        mypredlabelsList.append(int(ele))

    d = {'TestID': data[-1], 'DLOutput':myoutputlabelsList, 'PredLabel': mypredlabelsList , 'RealLabel': myreallabelsList, 'Vtype': vtype_labels}
    df = pd.DataFrame(data=d)
    df.to_excel("OutputSummary_" + myoptimizer+ modelname + str(randomSeed) + ".xlsx")  
 
    return data[-1] , output_dl_labels, new_predicted_labels, new_realLabel_array, vtype_labels


def predictMulticlassLabel(mymodel, testpath, maxlen, vecdim, myoptimizer, modelname, randomSeed):
    dataset = []
    testIDs = []
    reallabels = []
    predicted_labels = []
    output_dl_labels = []
    vtype_labels = []
    for filename in os.listdir(testpath):#"./data/DLInputs/test/"
        if filename.endswith(".pkl"):
            f = open(os.path.join(testpath, filename),"rb")
            data = pickle.load(f)
            f.close()
            dataset = data[0]
            reallabels = data[-2]
            vtype_labels = data[4]
            testIDs = data[-1] 
    if (len(dataset) == 1):#predict 1 program
        oneprogram = dataset[0]
        DL_labels = mymodel.predict(x = tranfromInput(oneprogram , maxlen, vecdim), batch_size=1)#for 1 program
    else:
        myarr = process_sequences_shape(dataset, maxlen, vecdim) # transforms test dataset into numpy arrays
        DL_labels = mymodel.predict(x=myarr, batch_size=1, verbose=1) # Why is it  returning an array of len 7 for each sample? what does each number stand for. HYPOTHESIS: one for each category. 
    
    outputs = mymodel.evaluate(myarr, reallabels)
    if not isinstance(outputs, list):
        outputs = [outputs]
    for name, output in zip(mymodel.metrics_names, outputs):
        print(f'{name} on predicted test dataset: {output}')
    
    # for l in DL_labels:
        # attempts to flattens array of arrays
        # output_dl_labels.append(l[0]) #  Why are we only appending the 1st number? I think this was for binary
    output_dl_labels, predicted_labels = get_predicted_class_and_accuracy(DL_labels)
    print(output_dl_labels[0:10])
    print(predicted_labels[0:10])
    # predicted_labels = DL_labels
    # for i in range(len( DL_labels)):
    #     if DL_labels[i]>= 0.5: # Crashing here b/c DL_labels[i] is an array of 1x7, but was expecting a single number
    #         predicted_labels[i] = 1
    #     else:
    #         predicted_labels[i] = 0
    totalPrograms  = len(dataset)
    print("predicted array shape: ", np.array(predicted_labels).shape)#numpy array (#totalprograms, 1) like (36,1) 36 rows 1 label columns
    #transform the real labels file to the same shape of predicted for model evaluation
    # TO DO: CONTINUE FIXING FROM HERE
    new_realLabel_array = np.reshape(reallabels, (totalPrograms,1))
    new_predicted_labels = np.reshape(predicted_labels, (totalPrograms,1))
    print("new real label array shape: " , new_realLabel_array.shape)
    
    myreallabelsList = []
    mypredlabelsList = []
    myoutputlabelsList = []
    for ele in new_realLabel_array:
        myreallabelsList.append(int(ele))
    for ele in output_dl_labels:
        myoutputlabelsList.append(float(ele))
    for ele in new_predicted_labels:
        mypredlabelsList.append(int(ele))

    d = {'TestID': data[-1], 'DLOutput':myoutputlabelsList, 'PredLabel': mypredlabelsList , 'RealLabel': myreallabelsList, 'Vtype': vtype_labels}
    df = pd.DataFrame(data=d)
    df.to_excel("OutputSummary_" + myoptimizer+ modelname + str(randomSeed) + ".xlsx")  
 
    return data[-1] , output_dl_labels, new_predicted_labels, new_realLabel_array, vtype_labels


